/** [[include:doc/maybe.md]] */
/** (keep typedoc from getting confused by the imports) */
import Result from './result';
/**
  Discriminant for the `Just` and `Nothing` variants.

  You can use the discriminant via the `variant` property of `Maybe` instances
  if you need to match explicitly on it.
 */
export declare enum Variant {
    Just = "Just",
    Nothing = "Nothing"
}
/** Simply defines the common shape for `Just` and `Nothing`. */
export interface MaybeShape<T> {
    /** Distinguish between the `Just` and `Nothing` [variants](../enums/_maybe_.variant). */
    readonly variant: Variant;
    /** Method variant for [`Maybe.isJust`](../modules/_maybe_.html#isjust) */
    isJust(this: Maybe<T>): this is Just<T>;
    /** Method variant for [`Maybe.isNothing`](../modules/_maybe_.html#isnothing) */
    isNothing(this: Maybe<T>): this is Nothing<T>;
    /** Method variant for [`Maybe.map`](../modules/_maybe_.html#map) */
    map<U>(this: Maybe<T>, mapFn: (t: T) => U): Maybe<U>;
    /** Method variant for [`Maybe.mapOr`](../modules/_maybe_.html#mapor) */
    mapOr<U>(this: Maybe<T>, orU: U, mapFn: (t: T) => U): U;
    /** Method variant for [`Maybe.mapOrElse`](../modules/_maybe_.html#maporelse) */
    mapOrElse<U>(this: Maybe<T>, orElseFn: () => U, mapFn: (t: T) => U): U;
    /** Method variant for [`Maybe.match`](../modules/_maybe_.html#match) */
    match<U>(this: Maybe<T>, matcher: Matcher<T, U>): U;
    /** Method variant for [`Maybe.or`](../modules/_maybe_.html#or) */
    or(this: Maybe<T>, mOr: Maybe<T>): Maybe<T>;
    /** Method variant for [`Maybe.orElse`](../modules/_maybe_.html#orelse) */
    orElse(this: Maybe<T>, orElseFn: () => Maybe<T>): Maybe<T>;
    /** Method variant for [`Maybe.and`](../modules/_maybe_.html#and) */
    and<U>(this: Maybe<T>, mAnd: Maybe<U>): Maybe<U>;
    /** Method variant for [`Maybe.andThen`](../modules/_maybe_.html#andthen) */
    andThen<U>(this: Maybe<T>, andThenFn: (t: T) => Maybe<U>): Maybe<U>;
    /** Method variant for [`Maybe.chain`](../modules/_maybe_.html#chain) */
    chain<U>(this: Maybe<T>, chainFn: (t: T) => Maybe<U>): Maybe<U>;
    /** Method variant for [`Maybe.flatMap`](../modules/_maybe_.html#flatmap) */
    flatMap<U>(this: Maybe<T>, flatMapFn: (t: T) => Maybe<U>): Maybe<U>;
    /** Method variant for [`Maybe.unwrap`](../modules/_maybe_.html#unwrap) */
    unsafelyUnwrap(): T | never;
    /** Method variant for [`Maybe.unwrapOrElse`](../modules/_maybe_.html#unwraporelse) */
    unwrapOrElse(this: Maybe<T>, elseFn: () => T): T;
    /** Method variant for [`Maybe.toOkOrErr`](../modules/_maybe_.html#tookorerr) */
    toOkOrErr<E>(this: Maybe<T>, error: E): Result<T, E>;
    /** Method variant for [`Maybe.toOkOrElseErr`](../modules/_maybe_.html#tookorelseerr) */
    toOkOrElseErr<E>(this: Maybe<T>, elseFn: () => E): Result<T, E>;
    /** Method variant for [`Maybe.toString`](../modules/_maybe_.html#tostring) */
    toString(this: Maybe<T>): string;
    /** Method variant for [`Maybe.equals`](../modules/_maybe_.html#equals) */
    equals(this: Maybe<T>, comparison: Maybe<T>): boolean;
    /** Method variant for [`Maybe.ap`](../modules/_maybe_.html#ap) */
    ap<U>(this: Maybe<(val: T) => U>, val: Maybe<T>): Maybe<U>;
}
/**
  A `Just` instance is the *present* variant instance of the
  [`Maybe`](../modules/_maybe_.html#maybe) type, representing the presence of a
  value which may be absent. For a full discussion, see [the module
  docs](../modules/_maybe_.html).

  @typeparam T The type wrapped in this `Just` variant of `Maybe`.
 */
export declare class Just<T> implements MaybeShape<T> {
    /**
      Unwrap the contained value. A convenience method for functional idioms.
  
      A common scenario where you might want to use this is in a pipeline of
      functions:
  
      ```ts
      import Maybe, { Just } from 'true-myth/maybe';
  
      function getLengths(maybeStrings: Array<Maybe<string>>): Array<number> {
        return maybeStrings
          .filter(Maybe.isJust)
          .map(Just.unwrap)
          .map(s => s.length);
      }
      ```
     */
    static unwrap<J>(theJust: Just<J>): J;
    /** `Just` is always [`Variant.Just`](../enums/_maybe_.variant#just). */
    readonly variant: Variant.Just;
    /** The wrapped value. */
    readonly value: T;
    /**
      Create an instance of `Maybe.Just` with `new`.
  
      @note While you *may* create the `Just` type via normal JavaScript
      class construction, it is not recommended for the functional style for
      which the library is intended. Instead, use [`Maybe.of`] (for the general
      case) or [`Maybe.just`] for this specific case.
  
      [`Maybe.of`]: ../modules/_maybe_.html#of
      [`Maybe.just`]: ../modules/_maybe_.html#just
  
      ```ts
      // Avoid:
      const aString = new Maybe.Just('characters');
  
      // Prefer:
      const aString = Maybe.just('characters);
      ```
  
      @param value
      The value to wrap in a `Maybe.Just`.
  
      `null` and `undefined` are allowed by the type signature so that the
      constructor may `throw` on those rather than constructing a type like
      `Maybe<undefined>`.
  
      @throws      If you pass `null` or `undefined`.
     */
    constructor(value?: T | null);
    /** Method variant for [`Maybe.isJust`](../modules/_maybe_.html#isjust) */
    isJust(this: Maybe<T>): this is Just<T>;
    /** Method variant for [`Maybe.isNothing`](../modules/_maybe_.html#isnothing) */
    isNothing(this: Maybe<T>): this is Nothing<T>;
    /** Method variant for [`Maybe.map`](../modules/_maybe_.html#map) */
    map<U>(this: Maybe<T>, mapFn: (t: T) => U): Maybe<U>;
    /** Method variant for [`Maybe.mapOr`](../modules/_maybe_.html#mapor) */
    mapOr<U>(this: Maybe<T>, orU: U, mapFn: (t: T) => U): U;
    /** Method variant for [`Maybe.mapOrElse`](../modules/_maybe_.html#maporelse) */
    mapOrElse<U>(this: Maybe<T>, orElseFn: () => U, mapFn: (t: T) => U): U;
    /** Method variant for [`Maybe.match`](../modules/_maybe_.html#match) */
    match<U>(this: Maybe<T>, matcher: Matcher<T, U>): U;
    /** Method variant for [`Maybe.or`](../modules/_maybe_.html#or) */
    or(this: Maybe<T>, mOr: Maybe<T>): Maybe<T>;
    /** Method variant for [`Maybe.orElse`](../modules/_maybe_.html#orelse) */
    orElse(this: Maybe<T>, orElseFn: () => Maybe<T>): Maybe<T>;
    /** Method variant for [`Maybe.and`](../modules/_maybe_.html#and) */
    and<U>(this: Maybe<T>, mAnd: Maybe<U>): Maybe<U>;
    /** Method variant for [`Maybe.andThen`](../modules/_maybe_.html#andthen) */
    andThen<U>(this: Maybe<T>, andThenFn: (t: T) => Maybe<U>): Maybe<U>;
    /** Method variant for [`Maybe.chain`](../modules/_maybe_.html#chain) */
    chain<U>(this: Maybe<T>, chainFn: (t: T) => Maybe<U>): Maybe<U>;
    /** Method variant for [`Maybe.flatMap`](../modules/_maybe_.html#flatmap) */
    flatMap<U>(this: Maybe<T>, flatMapFn: (t: T) => Maybe<U>): Maybe<U>;
    /** Method variant for [`Maybe.unsafelyUnwrap`](../modules/_maybe_.html#unsafelyunwrap) */
    unsafelyUnwrap(): T;
    /** Method variant for [`Maybe.unwrapOr`](../modules/_maybe_.html#unwrapor) */
    unwrapOr(this: Maybe<T>, defaultValue: T): T;
    /** Method variant for [`Maybe.unwrapOrElse`](../modules/_maybe_.html#unwraporelse) */
    unwrapOrElse(this: Maybe<T>, elseFn: () => T): T;
    /** Method variant for [`Maybe.toOkOrErr`](../modules/_maybe_.html#tookorerr) */
    toOkOrErr<E>(this: Maybe<T>, error: E): Result<T, E>;
    /** Method variant for [`Maybe.toOkOrElseErr`](../modules/_maybe_.html#tookorelseerr) */
    toOkOrElseErr<E>(this: Maybe<T>, elseFn: () => E): Result<T, E>;
    /** Method variant for [`Maybe.toString`](../modules/_maybe_.html#tostring) */
    toString(this: Maybe<T>): string;
    /** Method variant for [`Maybe.equals`](../modules/_maybe_.html#equals) */
    equals(this: Maybe<T>, comparison: Maybe<T>): boolean;
    /** Method variant for [`Maybe.ap`](../modules/_maybe_.html#ap) */
    ap<A, B>(this: Maybe<(val: A) => B>, val: Maybe<A>): Maybe<B>;
}
/**
  A `Nothing` instance is the *absent* variant instance of the
  [`Maybe`](../modules/_maybe_.html#maybe) type, representing the presence of a
  value which may be absent. For a full discussion, see [the module
  docs](../modules/_maybe_.html).

  @typeparam T The type which would be wrapped in a `Just` variant of `Maybe`.
 */
export declare class Nothing<T> implements MaybeShape<T> {
    /** `Nothing` is always [`Variant.Nothing`](../enums/_maybe_.variant#nothing). */
    readonly variant: Variant.Nothing;
    /**
      Create an instance of `Maybe.Nothing` with `new`.
  
      @note While you *may* create the `Nothing` type via normal JavaScript
      class construction, it is not recommended for the functional style for
      which the library is intended. Instead, use [`Maybe.of`] (for the general
      case) or [`Maybe.nothing`] for this specific case.
  
      [`Maybe.of`]: ../modules/_maybe_.html#of
      [`Maybe.nothing`]: ../modules/_maybe_.html#nothing
  
      ```ts
      // Avoid:
      const aNothing = new Maybe.Err();
  
      // Prefer:
      const aNothing = Maybe.nothing();
      ```
  
      `null` and `undefined` are allowed so that you may explicitly construct the
      `Err` type with a known `null` or `undefined` value. (This maybe helpful
      primarily when transitioning a codebase to the use of `Maybe`.)
  
      @throws      If you pass `null` or `undefined`.
     */
    constructor(_?: null);
    /** Method variant for [`Maybe.isJust`](../modules/_maybe_.html#isjust) */
    isJust(this: Maybe<T>): this is Just<T>;
    /** Method variant for [`Maybe.isNothing`](../modules/_maybe_.html#isnothing) */
    isNothing(this: Maybe<T>): this is Nothing<T>;
    /** Method variant for [`Maybe.map`](../modules/_maybe_.html#map) */
    map<U>(this: Maybe<T>, mapFn: (t: T) => U): Maybe<U>;
    /** Method variant for [`Maybe.mapOr`](../modules/_maybe_.html#mapor) */
    mapOr<U>(this: Maybe<T>, orU: U, mapFn: (t: T) => U): U;
    /** Method variant for [`Maybe.mapOrElse`](../modules/_maybe_.html#maporelse) */
    mapOrElse<U>(this: Maybe<T>, orElseFn: () => U, mapFn: (t: T) => U): U;
    /** Method variant for [`Maybe.match`](../modules/_maybe_.html#match) */
    match<U>(this: Maybe<T>, matcher: Matcher<T, U>): U;
    /** Method variant for [`Maybe.or`](../modules/_maybe_.html#or) */
    or(this: Maybe<T>, mOr: Maybe<T>): Maybe<T>;
    /** Method variant for [`Maybe.orElse`](../modules/_maybe_.html#orelse) */
    orElse(this: Maybe<T>, orElseFn: () => Maybe<T>): Maybe<T>;
    /** Method variant for [`Maybe.and`](../modules/_maybe_.html#and) */
    and<U>(this: Maybe<T>, mAnd: Maybe<U>): Maybe<U>;
    /** Method variant for [`Maybe.andThen`](../modules/_maybe_.html#andthen) */
    andThen<U>(this: Maybe<T>, andThenFn: (t: T) => Maybe<U>): Maybe<U>;
    /** Method variant for [`Maybe.chain`](../modules/_maybe_.html#chain) */
    chain<U>(this: Maybe<T>, chainFn: (t: T) => Maybe<U>): Maybe<U>;
    /** Method variant for [`Maybe.flatMap`](../modules/_maybe_.html#flatmap) */
    flatMap<U>(this: Maybe<T>, flatMapFn: (t: T) => Maybe<U>): Maybe<U>;
    /** Method variant for [`Maybe.unsafelyUnwrap`](../modules/_maybe_.html#unsafelyunwrap) */
    unsafelyUnwrap(): never;
    /** Method variant for [`Maybe.unwrapOr`](../modules/_maybe_.html#unwrapor) */
    unwrapOr(this: Maybe<T>, defaultValue: T): T;
    /** Method variant for [`Maybe.unwrapOrElse`](../modules/_maybe_.html#unwraporelse) */
    unwrapOrElse(this: Maybe<T>, elseFn: () => T): T;
    /** Method variant for [`Maybe.toOkOrErr`](../modules/_maybe_.html#tookorerr) */
    toOkOrErr<E>(this: Maybe<T>, error: E): Result<T, E>;
    /** Method variant for [`Maybe.toOkOrElseErr`](../modules/_maybe_.html#tookorelseerr) */
    toOkOrElseErr<E>(this: Maybe<T>, elseFn: () => E): Result<T, E>;
    /** Method variant for [`Maybe.toString`](../modules/_maybe_.html#tostring) */
    toString(this: Maybe<T>): string;
    /** Method variant for [`Maybe.equals`](../modules/_maybe_.html#equals) */
    equals(this: Maybe<T>, comparison: Maybe<T>): boolean;
    /** Method variant for [`Maybe.ap`](../modules/_maybe_.html#ap) */
    ap<A, B>(this: Maybe<(val: A) => B>, val: Maybe<A>): Maybe<B>;
}
/**
  Is this result a `Just` instance?

  @typeparam T The type of the wrapped value.
  @param maybe The `Maybe` instance to check.
  @returns     `true` if `maybe` is `Just`, `false` otherwise. In TypeScript,
               also narrows the type from `Maybe<T>` to `Just<T>`.
 */
export declare function isJust<T>(maybe: Maybe<T>): maybe is Just<T>;
/**
  Is this result a `Nothing` instance?

  @typeparam T The type of the wrapped value.
  @param maybe The `Maybe` instance to check.
  @returns     `true` if `maybe` is `nothing`, `false` otherwise. In TypeScript,
               also narrows the type from `Maybe<T>` to `Nothing<T>`.
 */
export declare function isNothing<T>(maybe: Maybe<T>): maybe is Nothing<T>;
/**
  Create an instance of `Maybe.Just`.

  `null` and `undefined` are allowed by the type signature so that the
  function may `throw` on those rather than constructing a type like
  `Maybe<undefined>`.

  @typeparam T The type of the item contained in the `Maybe`.
  @param value The value to wrap in a `Maybe.Just`.
  @returns     An instance of `Maybe.Just<T>`.
  @throws      If you pass `null` or `undefined`.
 */
export declare function just<T>(value?: T | null): Maybe<T>;
/**
  Create an instance of `Maybe.Nothing`.

  If you want to create an instance with a specific type, e.g. for use in a
  function which expects a `Maybe<T>` where the `<T>` is known but you have no
  value to give it, you can use a type parameter:

  ```ts
  const notString = Maybe.nothing<string>();
  ```

  @typeparam T The type of the item contained in the `Maybe`.
  @returns     An instance of `Maybe.Nothing<T>`.
 */
export declare function nothing<T>(_?: null): Maybe<T>;
/**
  Create a `Maybe` from any value.

  To specify that the result should be interpreted as a specific type, you may
  invoke `Maybe.of` with an explicit type parameter:

  ```ts
  const foo = Maybe.of<string>(null);
  ```

  This is usually only important in two cases:

  1.  If you are intentionally constructing a `Nothing` from a known `null` or
      undefined value *which is untyped*.
  2.  If you are specifying that the type is more general than the value passed
      (since TypeScript can define types as literals).

  @typeparam T The type of the item contained in the `Maybe`.
  @param value The value to wrap in a `Maybe`. If it is `undefined` or `null`,
               the result will be `Nothing`; otherwise it will be the type of
               the value passed.
 */
export declare function of<T>(value?: T | null): Maybe<T>;
/** Alias for [`of`](#of), primarily for compatibility with Folktale. */
export declare const fromNullable: typeof of;
/**
  Map over a `Maybe` instance: apply the function to the wrapped value if the
  instance is `Just`, and return `Nothing` if the instance is `Nothing`.

  `Maybe.map` works a lot like `Array.prototype.map`: `Maybe` and `Array` are
  both *containers* for other things. If you have no items in an array of
  numbers named `foo` and call `foo.map(x => x + 1)`, you'll still just have an
  array with nothing in it. But if you have any items in the array (`[2, 3]`),
  and you call `foo.map(x => x + 1)` on it, you'll get a new array with each of
  those items inside the array "container" transformed (`[3, 4]`).

  That's exactly what's happening with `Maybe.map`. If the container is *empty*
  – the `Nothing` variant – you just get back an empty container. If the
  container has something in it – the `Just` variant – you get back a container
  with the item inside transformed.

  (So... why not just use an array? The biggest reason is that an array can be
  any length. With a `Maybe`, we're capturing the idea of "something or
  nothing" rather than "0 to n" items. And this lets us implement a whole set
  of *other* interfaces, like those in this module.)

  #### Examples

  ```ts
  const length = (s: string) => s.length;

  const justAString = Maybe.just('string');
  const justTheStringLength = map(length, justAString);
  console.log(justTheStringLength.toString()); // Just(6)

  const notAString = Maybe.nothing<string>();
  const notAStringLength = map(length, notAString);
  console.log(notAStringLength.toString()); // "Nothing"
  ```

  @typeparam T The type of the wrapped value.
  @typeparam U The type of the wrapped value of the returned `Maybe`.
  @param mapFn The function to apply the value to if `Maybe` is `Just`.
  @param maybe The `Maybe` instance to map over.
  @returns     A new `Maybe` with the result of applying `mapFn` to the value
               in a `Just`, or `Nothing` if `maybe` is `Nothing`.
 */
export declare function map<T, U>(mapFn: (t: T) => U): (maybe: Maybe<T>) => Maybe<U>;
export declare function map<T, U>(mapFn: (t: T) => U, maybe: Maybe<T>): Maybe<U>;
/**
  Map over a `Maybe` instance and get out the value if `maybe` is a `Just`, or
  return a default value if `maybe` is a `Nothing`.

  #### Examples

  ```ts
  const length = (s: string) => s.length;

  const justAString = Maybe.just('string');
  const theStringLength = mapOr(0, length, justAString);
  console.log(theStringLength); // 6

  const notAString = Maybe.nothing<string>();
  const notAStringLength = mapOr(0, length, notAString)
  console.log(notAStringLength); // 0
  ```

  @typeparam T The type of the wrapped value.
  @typeparam U The type of the wrapped value of the returned `Maybe`.
  @param orU   The default value to use if `maybe` is `Nothing`
  @param mapFn The function to apply the value to if `Maybe` is `Just`
  @param maybe The `Maybe` instance to map over.
 */
export declare function mapOr<T, U>(orU: U, mapFn: (t: T) => U, maybe: Maybe<T>): U;
export declare function mapOr<T, U>(orU: U, mapFn: (t: T) => U): (maybe: Maybe<T>) => U;
export declare function mapOr<T, U>(orU: U): (mapFn: (t: T) => U) => (maybe: Maybe<T>) => U;
/**
  Map over a `Maybe` instance and get out the value if `maybe` is a `Just`,
  or use a function to construct a default value if `maybe` is `Nothing`.

  #### Examples

  ```ts
  const length = (s: string) => s.length;
  const getDefault = () => 0;

  const justAString = Maybe.just('string');
  const theStringLength = mapOrElse(getDefault, length, justAString);
  console.log(theStringLength); // 6

  const notAString = Maybe.nothing<string>();
  const notAStringLength = mapOrElse(getDefault, length, notAString)
  console.log(notAStringLength); // 0
  ```

  @typeparam T    The type of the wrapped value.
  @typeparam U    The type of the wrapped value of the returned `Maybe`.
  @param orElseFn The function to apply if `maybe` is `Nothing`.
  @param mapFn    The function to apply to the wrapped value if `maybe` is `Just`
  @param maybe    The `Maybe` instance to map over.
 */
export declare function mapOrElse<T, U>(orElseFn: () => U, mapFn: (t: T) => U, maybe: Maybe<T>): U;
export declare function mapOrElse<T, U>(orElseFn: () => U, mapFn: (t: T) => U): (maybe: Maybe<T>) => U;
export declare function mapOrElse<T, U>(orElseFn: () => U): (mapFn: (t: T) => U) => (maybe: Maybe<T>) => U;
/**
  You can think of this like a short-circuiting logical "and" operation on a
  `Maybe` type. If `maybe` is `Just`, then the result is the `andMaybe`. If
  `maybe` is `Nothing`, the result is `Nothing`.

  This is useful when you have another `Maybe` value you want to provide if and
  *only if* you have a `Just` – that is, when you need to make sure that if you
  `Nothing`, whatever else you're handing a `Maybe` to *also* gets a `Nothing`.

  Notice that, unlike in [`map`](#map) or its variants, the original `maybe` is
  not involved in constructing the new `Maybe`.

  #### Examples

  ```ts
  import Maybe from 'true-myth/maybe';

  const justA = Maybe.just('A');
  const justB = Maybe.just('B');
  const nothing: Maybe<number> = nothing();

  console.log(Maybe.and(justB, justA).toString());  // Just(B)
  console.log(Maybe.and(justB, nothing).toString());  // Nothing
  console.log(Maybe.and(nothing, justA).toString());  // Nothing
  console.log(Maybe.and(nothing, nothing).toString());  // Nothing
  ```

  @typeparam T    The type of the initial wrapped value.
  @typeparam U    The type of the wrapped value of the returned `Maybe`.
  @param andMaybe The `Maybe` instance to return if `maybe` is `Just`
  @param maybe    The `Maybe` instance to check.
  @return         `Nothing` if the original `maybe` is `Nothing`, or `andMaybe`
                  if the original `maybe` is `Just`.
 */
export declare function and<T, U>(andMaybe: Maybe<U>, maybe: Maybe<T>): Maybe<U>;
export declare function and<T, U>(andMaybe: Maybe<U>): (maybe: Maybe<T>) => Maybe<U>;
/**
  Apply a function to the wrapped value if `Just` and return a new `Just`
  containing the resulting value; or return `Nothing` if `Nothing`.

  This differs from `map` in that `thenFn` returns another `Maybe`. You can use
  `andThen` to combine two functions which *both* create a `Maybe` from an
  unwrapped type.

  You may find the `.then` method on an ES6 `Promise` helpful for b:
  if you have a `Promise`, you can pass its `then` method a callback which
  returns another `Promise`, and the result will not be a *nested* promise, but
  a single `Promise`. The difference is that `Promise#then` unwraps *all*
  layers to only ever return a single `Promise` value, whereas `Maybe.andThen`
  will not unwrap nested `Maybe`s.

  This is also commonly known as (and therefore aliased as) [`flatMap`] or
  [`chain`]. It is sometimes also known as `bind`, but *not* aliased as such
  because [`bind` already means something in JavaScript][bind].

  [`flatMap`]: #flatmap
  [`chain`]: #chain
  [bind]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/bind

  #### Example

  (This is a somewhat contrived example, but it serves to show the way the
  function behaves.)

  ```ts
  import Maybe from 'true-myth/maybe';

  // string -> Maybe<number>
  const toMaybeLength = (s: string): Maybe<number> => Maybe.of(s.length);

  // Maybe<string>
  const aMaybeString = Maybe.of('Hello, there!');

  // Maybe<number>
  const resultingLength = Maybe.andThen(toMaybeLength, aMaybeString);
  console.log(Maybe.toString(resultingLength)); // 13
  ```

  Note that the result is not `(Just(13))`, but `13`!

  @typeparam T  The type of the wrapped value.
  @typeparam T  The type of the wrapped value in the resulting `Maybe`.
  @param thenFn The function to apply to the wrapped `T` if `maybe` is `Just`.
  @param maybe  The `Maybe` to evaluate and possibly apply a function to the
                contents of.
  @returns      The result of the `thenFn` (a new `Maybe`) if `maybe` is a
                `Just`, otherwise `Nothing` if `maybe` is a `Nothing`.
 */
export declare function andThen<T, U>(thenFn: (t: T) => Maybe<U>, maybe: Maybe<T>): Maybe<U>;
export declare function andThen<T, U>(thenFn: (t: T) => Maybe<U>): (maybe: Maybe<T>) => Maybe<U>;
/** Alias for [`andThen`](#andthen). */
export declare const chain: typeof andThen;
/** Alias for [`andThen`](#andthen). */
export declare const flatMap: typeof andThen;
/**
  Provide a fallback for a given `Maybe`. Behaves like a logical `or`: if the
  `maybe` value is a `Just`, returns that `maybe`; otherwise, returns the
  `defaultMaybe` value.

  This is useful when you want to make sure that something which takes a
  `Maybe` always ends up getting a `Just` variant, by supplying a default value
  for the case that you currently have a nothing.

  ```ts
  import Maybe from 'true-utils/maybe';

  const justA = Maybe.just("a");
  const justB = Maybe.just("b");
  const aNothing: Maybe<string> = nothing();

  console.log(Maybe.or(justB, justA).toString());  // Just(A)
  console.log(Maybe.or(aNothing, justA).toString());  // Just(A)
  console.log(Maybe.or(justB, aNothing).toString());  // Just(B)
  console.log(Maybe.or(aNothing, aNothing).toString());  // Nothing
  ```

  @typeparam T        The type of the wrapped value.
  @param defaultMaybe The `Maybe` to use if `maybe` is a `Nothing`.
  @param maybe        The `Maybe` instance to evaluate.
  @returns            `maybe` if it is a `Just`, otherwise `defaultMaybe`.
 */
export declare function or<T>(defaultMaybe: Maybe<T>, maybe: Maybe<T>): Maybe<T>;
export declare function or<T>(defaultMaybe: Maybe<T>): (maybe: Maybe<T>) => Maybe<T>;
/**
  Like `or`, but using a functi